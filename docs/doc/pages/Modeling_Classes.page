[[Category:Ambrosia]]
'''Ambrosia Modeling Classes''' are central to the development of models in the [[Ambrosia]] modeling environment.<br>
[[#The_bunny_Object|bunny]]
[[#The_Camera_Class|Camera]]
[[#The_Cone_Class|Cone]]
[[#The_Context_Class|Context]]
[[#The_Cube_Class|Cube]]
[[#The_CubicSurface_Class|CubicSurface]]
[[#The_Cylinder_Class|Cylinder]]
[[#The_Difference_Class|Difference]]
[[#The_Environment_Class|Environment]]
[[#The_Image_Class|Image]]
[[#The_InfiniteCone_Class|InfiniteCone]]
[[#The_InfiniteHyperboloid_Class|InfiniteHyperboloid]]
[[#The_InfiniteParaboloid_Class|InfiniteParaboloid]]
[[#The_InfiniteSaddle_Class|InfiniteSaddle]]
[[#The_Intersection_Class|Intersection]]
[[#The_Spindle_Class|Spindle]]
[[#The_Lemniscate_Class|Lemniscate]]
[[#The_Light_Class|Light]]
[[#The_Material_Class|Material]]
[[#The_AmbrosiaObject_Class|AmbrosiaObject]]
[[#The_Mesh_Class|Mesh]]
[[#The_PatchMesh_Class|PatchMesh]]
[[#The_Piriform_Class|Piriform]]
[[#The_Plane_Class|Plane]]
[[#The_Primitive_Class|Primitive]]
[[#The_Prism_Class|Prism]]
[[#The_QuadricSurface_Class|QuadricSurface]]
[[#The_QuarticSurface_Class|QuarticSurface]]
[[#The_Reference_Class|Reference]]
[[#The_scene_Object|scene]]
[[#The_Sphere_Class|Sphere]]
[[#The_SpotLight_Class|SpotLight]]
[[#The_Superellipsoid_Class|Superellipsoid]]
[[#The_StereoCamera_Class|StereoCamera]]
[[#The_Surface_Class|Surface]]
[[#The_teapot_Object|teapot]]
[[#The_Torus_Class|Torus]]
[[#The_TorusSurface_Class|TorusSurface]]
[[#The_Transform_Class|Transform]]
[[#The_Transformable_Class|Transformable]]
[[#The_Union_Class|Union]]
== Overview ==
All features of an Ambrosia model, including the physical object, the camera,
the lights and materials, are described by an important structure called an
''Ambrosia object''.  These modeling objects provide information about the state
of the corresponding virtual object.  For example, a cube to be modeled by
Ambrosia is represented as an instance of a [[#The_Cube_Class|Cube]] class.  The
cube's position in space, its dimensions, and material are all represented by
its ''state''.  The particular [[#The_Cube_Class|Cube]] instance (below,
breadBox) contains this state information.  When the modeler is interested in
state properties, the modeler writes Ambrosia expressions that ''send messages''
to (or '''tell''') the object to change or report its state.  The breadBox is
responsible for reacting to those messages, returning portions of the state,
or possibly modifying the state to reflect the intent of the messages it is
sent.

So, for example, several instances of the Ambrosia <code>Box</code> object with the following expressions:
 # construct cubes
 cube = Cube()
 cube2 = Cube()
 # translate cube 150 to the left
 cube.translate(-150,0,0)
 breadBox=Cube()
 # double width of cube, then translate to the right, 200
 breadBox.scale(2,1,1).translate(200,0,0)
Three instances of a Cube class are created.  The first, <code>cube</code>
object is a cube located at the origin with width, height, and depth 100.  The
second, <code>cube2</code> is a similar object, that is translated 100 units
to the left along the x-axis.  The final <code>Cube</code> object is twice as
wide--200 units--as it is tall or deep and is translated to the right 200
units.

== Grouping Classes ==

=== The Group Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Group class allows the Ambrosia modeler to combine objects into a single
logical object.  For example, a <code>person</code> might be composed of a
head, a torso, two legs, and two arms.  Once the group is constructed, it may
be added to groups to help with the construction of hierarchical models.

; .add(object,...) : A reference to an object is added to the group.  Zero or 
more messages arguments that result in transformations, materials, or tags 
may be applied to this particular reference.

Related classes are the [[#The Difference Class|Difference]] and [[#The Intersection Class|Intersection]] classes, below.

=== The scene Object ===
<b>Instance of:</b> [[#The_Group_Class|Group]]<br>
The scene object is a predefined instance of the group class that contains a [[#The_bulb_Object|bulb]].  The scene object is also the subject of the [[#The_camera_Object|camera]] object.  The definition of scene is:
 scene = Group()
 scene.add(bulb,translate(0,300,0))

== Camera Classes ==
=== The Image Class ===
<b>Parent:</b> [[#The_AmbrosiaObject_Class|AmbrosiaObject]]<br>

Images describe the characteristics of the images generated by the [[#The_Camera_Class|Camera]] objects.  Image state includes the background color, and the dimensions of the resulting picture.

; .background(color) : Sets the color of the background for the image.  By default, we use '''cyan'''.
; .dimensions(w,h) : Sets the width and height of the image.  The aspect ratio always reflects the ratio of width to height.
; .width(w) : Sets the width of the resulting image, in pixels.  ''The height is also reset to preserve the aspect ratio.''
; .height(h) : Sets the height of the image, in pixels.  ''The width is also reset to preserve the aspect ratio.''
; .aspectRatio(r) :  Resets the aspect ratio (width/height) of the image.  The width remains the same, but the height is recalculated to reflect the new aspect ratio.
; .quality(level) : Sets general image quality.  Level is a value between 1 and 10.  A level 1 quality image is rendered quickly, but probably inaccurately.  A level 10 quality image renders slowly, but accurately.
; .antiAlias(v) : Sets the antialiasing level to v.  V is a value between 0 and 1.  0 leaves the image with possibly aliased pixels.  1 smooths the image to avoid "pixelation" along high contrast edges.  The default value is 0.5.
The builtin object '''image''' sets the parameters for the builtin [[#The_Camera_Class|Camera]] object, '''camera'''.

=== The Camera Class ===
<b>Parent:</b> [[#The_AmbrosiaObject_Class|AmbrosiaObject]]<br>
The Camera class is the template for the construction of devices for taking pictures of models.  One predefined instance, [[#The_camera_Object|camera]], is typically used to construct images of the default scene, [[#The_scene_object|scene]].

To support its particular interpretation of its subject, a Camera object maintains several pieces of information:
* Position.  Where the camera is located in space.
* Center of interest.  This point is in the center of the image shot by the camera.
* Up direction vector.  A vector that describes the direction of 'up' in the scene.  The vector is typically (0 1 0).  Any translation of the up vector into the view of the camera would appear to point upward in the image.

; .pos(p) : Set the position of the camera to p.
; .pos(xform) : Transform the current position of the camera by applying xform to the camera's current position.
; .getPos() : Get the current position of the camera.
; .COI(p) : Set the center of interest for the camera to p.   Point p will appear in the image.
; .COI(xform) : Change the center of interest by transforming it by xform.
; .up(d) : Set the vector pointing upward to d.  This vector is typically '(0 1 0).
; .getUp(): Get the upward pointing direction vector for the camera.
; .image(i) : Sets the [[#The_Image_Class|image]] associated with the Camera.
; .getImage() : Gets the [[#The_Image_Class|image]] associated with this Camera.
; .subject(object) : Identify the <i>symbol</i> associated with the subject of the scene.
; .getSubject() : Returns the symbol identifying the subject of the camera.
; .shoot() : Shoots an image (using the POV renderer, by default).
; .proof() : Constructs the POV image file and prints it on the output.  The image is not sent to POV.
; .angle(theta) : Sets the angle of the view volume associated with this Camera.   By default, this is 53 degrees.  Smaller values create a "telephoto" effect.  Larger values create a "wide angle" view effect.
; .orthographic() : Sets this Camera to use an orthographic projection rather than the default perspective projection.
; .perspective() : Sets this Camera to use a perspective projection.  This is the default behavior.

=== The StereoCamera Class ===
<b>Parent:</b> [[#The_Camera_Class|Camera]]<br>
The StereoCamera class extends a Camera to provide a biocular or ''stereo'' camera.  Such cameras render ''anaglyph'' pictures.  The StereoCamera works as a regular camera, but takes a pair of pictures separated by a small, positive distance from the camera position.  Both cameras of the stereo pair have the same center of interest, which is found at the center of both images.  The StereoCamera provides the following additional methods:

; .separation(d) : Set the separation of the camera pair to d units.
; .getSeparation() : Get the separation of the camera pair.

[[Image:StereoBunny.png|none|thumb|150px|A StereoCamera anaglyph.]]

== Lighting Classes ==

=== The Light Class ===

=== The SpotLight Class ===

== Material Classes ==

=== The Material Class ===
<b>Parent:</b> [[#The_AmbrosiaObject_Class|AmbrosiaObject]]<br>

This class is used to represent all of the different characteristics of the materials from which objects are constructed.  Many objects are constructed from solid, uniformly structured materials.  The following '''Material''' messages determine the parameters that describe these materials:

; .color(c) : Set the native color of the material to c.  c may be an RGB triple, or an [[#The_AmbrosiaColor_Class|AmbrosiaColor]] object.
; .type(symbol)  : Set general parameters to common settings.  If symbol is 'plaster, the material is opaque and non-reflective.  If symbol is 'plastic, the material is opaque, smooth, and somewhat reflective.  If symbol is 'glass, the material is transparent, with some reflection and specular highlighting, with refraction about 1.5.  If type is 'mirror, the material is opaque, with little diffuse color and highly reflective.
; .diffuse(level) : Level, a value between 0 and 1, determines the amount of the object's color that is determined by its native color.  If this value is 0, the object is only colored by ambient light, reflection, specular highlights, transparency, etc.  If the value is 1, color of opaque objects will be determined by the native color of the object.
; .roughness(level) : Level, a non-zero, positive value, determines how rough the object appears.  Small values (e.g. 0.05) suggest smooth objects, while relatively large values (e.g. 1) suggest more rough or porous surfaces.  Plasters, for example, have roughness 1 or more.
; .reflection(level) : Level, a value between 0 and 1, determines the amount of light incident on an object that is reflected.  A level of 0 is typical of plasters and other non-reflective objects.  A value of 1 is typical of mirrors.
; .specularity(level) : Level, a value between 0 and 1, determines the degree to which lights generate specular highlights.  Specular highlights are important to giving hints on surface shapes.  A value of  0 is typical of plasters, while a value of 1 is typical of plastics, glasses, and metals, but not mirrors.

Materials that exhibit transparency are determined by these additional parameters (all of the above parameters are useful in transparent materials as well):

;  .transparency(level) : Level, a value between 0 and 1, determines the percentage of incident light that will travel through the object.  Opaque objects have 0 transparency, while a crystal ball has transparency 1.  Perfectly transparent objects are not common.
; .refraction(index): Index, a value typically larger than 1, determines the index of refraction for the material.  The index of refraction for water is about 1.33, glass is about 1.4, and diamond is 2.4. Here is a [http://en.wikipedia.org/wiki/List_of_indices_of_refraction table of refractive indices] at Wikipedia.

== Basic Geometric Classes ==

=== The Cube Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Cube class provides a prototype for a 100x100x100 cube, centered at the origin.

=== The Sphere Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Sphere is a sphere, with diameter 100, centered at the origin.  It may be scaled, of course, to generate other ellipsoid solids.

; .radius(r) : Sets the radius of the sphere to r.  By default, the radius is 50; the diameter is 100.
; .getRadius(r) : Gets the radius associated with the sphere.
; .center(p) : Sets the center of the sphere to p.  By default, the center is '(0 0 0).
; .getCenter() : Gets the center of the sphere.



=== The Cone Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Cone class constructs a portion of a cone, pointing upward.  The ends are centered at the top and bottom, and the respective radii determine the size of the caps.  Capping the cone makes it solid.  By default, the cone points upward along the y-axis, and is 100x100x100 and capped.

; .topCenter(p) : Sets the top center of the cone.
; .getTopCenter() : Returns the top center of the cone.
; .topRadius(r) : Sets the radius of the top of the cone.
; .getTopRadius(r) : Gets the top radius.
; .bottomCenter(p) : Sets the bottom center of the cone.
; .getBottomCenter() : Gets the bottom center of the cone.
; .bottomRadius(r) : Sets the radius of the bottom of the cone.
; .getBottomRadius() : Gets the bottom radius.
; .capped(status) : Adds cap to ends iff status is #t.
; .getCapped() : Gets the capping status.

=== The Cylinder Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Cylinder class constructs a cylinder along the y-axis.  The ends are centered at the top and bottom, and the radius determines the size of the caps.  Capping the cylinder makes it solid.  By default, the cylinder is 100x100x100 and capped.

; .topCenter(p) : Sets the top center of the cylinder.
; .getTopCenter) : Returns the top center of the cylinder.
; .radius(r) : Sets the radius of the cylinder.
; .getRadius(r) : Gets the radius.
; .bottomCenter(p) : Sets the bottom center of the cylinder.
; .getBottomCenter() : Gets the bottom center of the cylinder.
; .capped(status) : Adds cap to ends iff status is #t.
; .getCapped() : Gets the capping status.

== Complex Geometric Classes ==

=== The Superellipsoid Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Superellipsoid class implements an ellipsoid with controllable roundness factors.  The superellipsoid is controlled using two roundness coefficients: the xz roundness controls the roundness of the ellipse where the xz-plane cuts the structure.  The second (yz roundness) controls the ellipse where the yz-plane cuts through the object.

A roundness of 1 generates elliptic cross sections.  A roundness of 0 generates square shape.  A roundness of 2 generates a diamond.  

; .roundness(xy,yz) : Sets the roundness factors for the superellipsoid.
; .getRoundness(: Retrieves the list of roundness factors as (xy yz)

=== The Torus Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Torus is an object constructed by drawing a cylinder around in a circle, connecting its ends.  The standard torus encircles the y axis and is split by the xz-plane. Two parameters control the shape of the torus: the minor radius - the radius of the cylinder, and the major radius - the radius of the circle that forms the median of the torus.  The height of the torus is, therefore twice the minor radius, and the width and depth of the torus is 2(minor+major).

; .minor(mr) : Sets the minor radius of the torus.  By default, this is 25.
; .major(mr) : Sets the major radius of the torus.  By default, this is 25.
; .getMinor() : Gets the minor radius.
; .getMajor() : Gets the major radius.
; .sturmian(state) : Sets the Sturmian root solver on (#t) or off (#f).
The default is off; on renders more slowly.
; .getSturmian() : Retrieves the Sturmian state.

== The Surface Classes ==

=== The Surface Class ===

=== The QuadricSurface Class ===

=== The CubicSurface Class ===

=== The QuarticSurface Class ===

=== The TorusSurface Class ===

=== The Lemniscate Class ===

=== The Piriform Class ===

== Turned and Extruded Classes ==

=== The Prism Class ===
<b>Parent:</b> [[The_Primitive_Class|Primitive]]<br>
Prisms objects are the result of extruding model material through a template (specified as a 3D polygon in the xy-plane) upward along the z-axis.  By default, it is 100 units long (from z=-50, to z=50).  The polygon represents the cross section of the Prism.  This cross section may be composed of linear segments (the default); or cubic or bezier splines.

; .linear() : Constructs a template by using a polygon of linear segments.  This is the default.
; .cubic() : Constructs a template by using a polygon constructed from cubic splines.
; .bezier() : Constructs a template by using a polygon constructed from bezier splines.
; .getType() : Returns 'linear, 'cubic, or 'bezier, depending on the polygon type.
; .sturm() : Turns on the use of the Sturmian root finder.  The Sturmian root finder generates more accurate renderings, but is slower.
; .getSturm() : Returns #t iff the Sturmian root finder will be used.

=== The Spindle Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
Objects of the Spindle type are constructed as though they had been turned on a lathe.
The modeler specifies the outline of the shape (thought of as 2D coordinates in the xy plane); and outline is spun about the axis.  If the outline meets the y-axis, then the object is essentially capped.  If the first point is repeated, then the object will be solid.  If there are multiple closed polygons, each is swept independently and where an odd number of swept surfaces contain a point, that point is inside the swept object.

Points on the surface may be connected in a linear, cube, or bezier fashion.

; .linear() : The outline of the cross section is composed of line segments.  This is the default type.
; .cubic() : The outline of the cross section is composed of cubic splines.
; .bezier() : The outline of the cross section is composed of Bezier splines.
; .getType() : Returns 'linear, 'cubic, or 'bezier, depending on the type.
; .sturm() : Use a Sturmian root finder, which more accurately models the surface of spline-swept objects.  It is, however, slower.
; .getSturm() : returns #t iff the Sturmian root finder will be used.  By default, this is #f.

== Infinite Geometric Classes  ==
=== The Plane Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]].<br>
The Plane class implements an infinite, two-dimensional plane extending through model space.  By default, the object occupies the xz-plane, going through the origin.  Plane objects may be tilted and moved away from the origin by specifying a ''normal vector'', a vector that, if the plane were to sit at the origin, would extend outward, and an offset, which indicates how far the plane is from the origin along the normal vector.

; .normal(x,y,z): Specifies the normal vector.  This vector should be nonzero.
; .getNormal(): Returns the normal vector for the plane.  By default, this vector is '(0 1 0).
; .offset(d): Specifies the distance from the plane to the origin.  The point offset units from the origin along the normal vector resides on the plane.
; .getOffset(d): Gets the plane offset.

=== The InfiniteCone Class ===

=== The InfiniteParaboloid Class ===

=== The InfiniteHyperboloid Class ===

=== The InfiniteSaddle Class ===

== Mesh Classes ==

=== The Mesh Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Mesh class allows the modeling of surfaces composed of triangles.  Each mesh is composed of four things:
# A vertex list.  Each element of the list is a unique 3D vertex.
# A triangle list.  Each element is a triple of vertex list indices.  It describes the triangle.
# A UV-vertex list.
# A UV-triangle list.

; .register(v) : Takes a 3D-vertex, v, and adds it to the vertex list.  Returns the index of the vertex.
; .addTri(t) : Takes a list of three 3D-vertices, registers each of the vertices, and adds the corresponding triangle to the triangle list.
; .uvRegister(uvv) : Takes a 2D-vertex, uvv, and add it to the list of uv-vertices.  Returns the index of the vertex in the list.
; .addUVTri(t,uv) : Takes a list of two triangles: a list (t) of three 3D-vertices and a list (uv) three 2D-vertices, registers each vertex, and adds the corresponding triangle to the triangle list, and uv-triangle to the uv-triangle list.

=== The Bunny Class ===
<b>Extension of:</b> [[#The_Mesh_Class|Mesh]]<br>
The Bunny Class produces mesh models of the Stanford Bunny.  It has 69451 triangular faces.  It has four holes in the base.  The bunny is 100 units wide, 99.125 units tall, and 72.5 units deep.  It sits centered on the xz-plane.  You must include the definition of the Bunny class with the command:
 from ambrosia.zoo.bunny import Bunny
Once the definition has been included, the modeler typically creates an instance of the class:
 hopper=Bunny()

[[Image:AmbrosiaBunny.jpg|none|thumb|150px|Ambrosia's Stanford Bunny]]

=== The PatchMesh Class ===

=== The Teapot Class ===
<b>Extension of:</b> [[#The_Mesh_Class|Mesh]]<br>
The teapot is a PatchMesh that implements Newell's teapot.  The teapot is 100 units wide, 48.25 units tall, 61.3 units deep.  It sits centered, sitting on the xz-plane.  You must include the definition of the Teapot class with the command:
 from ambrosia.zoo.teapot import Teapot
Once the definition has been included, the modeler typically creates an instance of the class:
 tp = Teapot()

[[Image:AmbrosiaTeapot.jpg|none|thumb|150px]]

== Constrained Solid Geometry Classes ==

=== The Group Class ===

=== The Intersection Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Intersection class allows the Ambrosia modeler to compute the intersections of a series of objects, producing a single logical object.  For example, an alien space ship might be the result of intersecting two spheres.  Once the intersection is constructed, it may be added to groups to help with the construction of hierarchical models.

; .add(object...) : A reference to an object is added to the group. The final surface must be contained within each object that is added to the intersection.

=== The Difference Class ===
<b>Parent:</b> [[#The_Primitive_Class|Primitive]]<br>
The Difference class allows the Ambrosia modeler to compute the difference of objects, producing a single logical object.  For example, a <code>eye</code> might be composed of a eyeball, less a pupil.  Once the Difference is constructed, it may be added to groups to help with the construction of hierarchical models.

; .add(object,message...) : A reference to an object is added to the group.  Zero or more messages that result in transformations, materials, or tags may be applied to this particular reference.  ''The first'' reference added is positive matter.  ''Successive'' references are used to annihilate, or scoop away from the matter.  The material associated with each surface is determined by the object that created that surface.

== Internal Classes ==

=== The AmbrosiaObject Class ===
<b>Root of all Ambrosia classes</b><br>
This object is the root of all Ambrosia classes.  It provides some basic operations that are available to all derived classes:

; .describe() : This method returns the list of attributes associated with the object.  Not for external use.
; .description(s) : Sets the descriptive string of this object to s.
; .attributes(l) : Explicitly sets the attribute list associated with this object to list l.  Not fo external use.
; .attr(a,v) : Sets attribute a to have value v.
; .getAttr(a) : Gets value associated with attribute a.

===The Environment Class===
<b>Parent:</b> [[#The_AmbrosiaObject_Class|AmbrosiaObject]]<br>
The Environment class keeps track of the settings for the current environment.  There is one builtin instance of this class, '''environment'''.  The typical modeler does not need to create new instances of the Environment.  Currently, the Environment does not support any public messages.

=== The Transform Class ===

<b>Parent:</b> [[#The_AmbrosiaObject_Class|AmbrosiaObject]]<br>
The Transform class implements a 3D graphical transformation.

; .mapPoint(p) : Maps a 3D point through the transformation.
; .yzMirror() : Appends a mirror through the yz-plane to the transformation.
; .xyMirror() : Appends a mirror through the xy-plane to the transformation.
; .xzMirror() : Appends a mirror through the xz-plane to the transformation.
; .xRot(angle) : Appends a rotation about the x-axis by angle (in degrees).
; .yRot(angle) : Appends a rotation about the y-axis by angle (in degrees).
; .zRot(angle) : Appends a rotation about the z-axis by angle (in degrees).
; .scale(x,y,z) : Appends a scaling by factors x (along x axis); y, and z.
; .translate(dx,dy,dz) : Appends a shift along the vector from the origin to dx, dy, and dz.
; .prefixWith(xform) : Prepends this transformation with the transformation represented by xform.
; .suffixWith(xform) : Appends this transformation with the transformation represented by xform.
; .normalize() : Reduces the transform to canonical, normalized form.
; .xform() : Returns matrix associated with this transform.
; .getHistory() : Returns the sequence of operations necessary to generate this transformation.

=== The Transformable Class ===
<b>Parent:</b> [[#The_AmbrosiaObject_Class|AmbrosiaObject]]<br>
Transformables correspond to objects that may be transformed through space.  These include models, lights, and cameras.

Transformables may also be tagged.  These tags provide a means of describing the purpose of the object.  Once constructed, Transformable objects may be selectively rendered based on their tags.

; .getTags() : Gets list of tags associated with this object.
; .tag(sym...) : Unions one or more tag symbols with the list of tags already used on this object.  If the object is already tagged with a particular tag, it will not be retagged.
; .untag(sym...) : Removes each of the tags symbols specified from list of tags associated with this Transformable.
; .hasTag(t) : Returns #t iff this Transformable has the tag t.
; .getXForm() : Returns transform associated with this Transformable object.
; .centroid(p) : Sets the center of mass for this object to be at point p.  Typically this is automatically set at object construction.
; .getCentroid(p) : Returns the center of mass for this transformable object.
; .yzMirror() : Mirrors Transformable through the yz-plane to the transformation.
; .xyMirror() : Mirrors Transformable through the xy-plane to the transformation.
; .xzMirror() : Mirrors Transformable through the xz-plane to the transformation.
; .xRot(angle) : Rotates Transformable about the x-axis by angle (in degrees).
; .yRot(angle) : Rotates Transformable about the y-axis by angle (in degrees).
; .zRot(angle) : Rotates Transformable about the z-axis by angle (in degrees).
; .scale(x,y,z) : Scales Transformable by factors x (along x axis); y, and z.
; .translate(dx,dy,dz) : Shifts Transformable along the vector from the origin to dx, dy, and dz.

=== The Primitive Class ===
<b>Parent:</b> [[#The_Transformable_Class|Transformable]]<br>
Primitive objects are Transformable objects to whom materials may be attached.  These objects are the basis for object that can be directly photographed using Cameras.

; .material(m) : Sets the material associated with the object to m.
; .getMaterial() : Gets the material associated with the object.

=== The Context Object ===
<b>Parent:</b> [[#The_AmbrosiaObject_Class|AmbrosiaObject]]<br>
Contexts maintain information about the current transformation, material, and tags during the process of an object traversal.  These structures are not generally useful to external classes.

; .maxDepth(d) : Sets the maximum depth associated with this Context to d.
; .getMaxDepth() : Gets the maximum depth associated with this Context.
; .down() : Increases the stack depth associated with this Context.
; .up() : Decreases the stack depth associated with this Context.
; .top() : Peeks at the top transform on the transform stack.
; .total() : Computes the product of all transforms on the transform stack.
; .topMat() : Peeks at the top material on the material stack.
; .mergeMaterials() : Merges all materials on the material stack.
; .topTags() : Peeks at the top tag list on the tags stack.
; .mergeTags() : Computes the union of all tag lists on the tag stack.
; .pushTransform(t) : Pushes the Transform, t, onto the transform stack.
; .popTransform() : Pops and returns a Transform from the transform stack.
; .pushMaterial(m) : Pushes the Material, m, onto the material stack.
; .popMaterial() : Pops and returns a Material from the material stack.
; .pushTags(tl) : Pushes a tag list, tl, onto the tag stack.
; .popTags(tl) : Pops a tag list from the tag stack.
; .mapPoint(p) : Maps a point through the product of the transforms on the transform stack.

=== The Reference Class ===
